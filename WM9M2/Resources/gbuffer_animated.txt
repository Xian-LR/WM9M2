// gbuffer_animated.txt - Animated version with normal mapping support

// Transform matrices and bone data
cbuffer animatedMeshBuffer
{
    float4x4 W;
    float4x4 VP;
    float4x4 bones[64];
};

// Alpha testing
cbuffer AlphaCutCB
{
    float alphaCutoff;
    float3 _padAlphaCutCB;
};

struct VS_INPUT {
    float4 Pos        : POS;
    float3 Normal     : NORMAL;
    float3 Tangent    : TANGENT;
    float2 TexCoords  : TEXCOORD;
    uint4 BoneIDs     : BONEIDS;
    float4 BoneWeights: BONEWEIGHTS;
};

struct PS_INPUT {
    float4 Pos       : SV_POSITION;
    float3 WorldPos  : WORLDPOS;
    float3 Normal    : NORMAL;
    float3 Tangent   : TANGENT;
    float3 Binormal  : BINORMAL;
    float2 TexCoords : TEXCOORD0;
};

struct PS_OUTPUT
{
    float4 color : SV_Target0;
    float4 normal : SV_Target1;
};

// Texture inputs
Texture2D diffuseTexture : register(t0);
Texture2D normalTexture : register(t1);
SamplerState samplerLinear : register(s0);

PS_INPUT VS(VS_INPUT input)
{
    PS_INPUT o;
    
    // Bone animation calculation
    float4x4 skinMatrix = bones[input.BoneIDs.x] * input.BoneWeights.x +
                         bones[input.BoneIDs.y] * input.BoneWeights.y +
                         bones[input.BoneIDs.z] * input.BoneWeights.z +
                         bones[input.BoneIDs.w] * input.BoneWeights.w;
    
    // Apply bone transformation
    float4 skinnedPos = mul(input.Pos, skinMatrix);
    float3 skinnedNormal = mul(input.Normal, (float3x3)skinMatrix);
    float3 skinnedTangent = mul(input.Tangent, (float3x3)skinMatrix);
    
    // Transform to world space
    float4 worldPos = mul(skinnedPos, W);
    o.WorldPos = worldPos.xyz;
    o.Pos = mul(worldPos, VP);
    
    // Transform normals and tangents to world space
    o.Normal = normalize(mul(skinnedNormal, (float3x3)W));
    o.Tangent = normalize(mul(skinnedTangent, (float3x3)W));
    o.Binormal = normalize(cross(o.Normal, o.Tangent));
    
    o.TexCoords = input.TexCoords;
    return o;
}

PS_OUTPUT PS(PS_INPUT input)
{
    PS_OUTPUT output;
    
    // Sample diffuse texture
    float4 diffuse = diffuseTexture.Sample(samplerLinear, input.TexCoords);
    
    if (diffuse.a < alphaCutoff) 
    {
        discard;
    }
    
    // Sample and decode normal map
    float3 normalMap = normalTexture.Sample(samplerLinear, input.TexCoords).rgb;
    normalMap = normalMap * 2.0 - 1.0;
    
    // Build TBN matrix
    float3 N = normalize(input.Normal);
    float3 T = normalize(input.Tangent);
    float3 B = normalize(input.Binormal);
    
    if (dot(cross(N, T), B) < 0.0)
        T = T * -1.0;
    
    float3x3 TBN = float3x3(T, B, N);
    
    // Transform normal to world space
    float3 worldNormal = normalize(mul(normalMap, TBN));
    
    output.color = float4(diffuse.rgb, 1.0);
    output.normal = float4(worldNormal * 0.5 + 0.5, 1.0);
    
    return output;
}